# Algorithm-Design-Pattern

**자료구조(저장소)가 중요한 이유 -변경 줘서 출력하려면, 일단 변경된 상태로 저장이 되어야 가능**

정렬
<h1> Q1 TEMP가 필요한 이유</h1> (프로그래밍은 그냥 암기가 아니라, 왜에 대한 증명을 해주는 식으로 해야 실력이 는다) 

EX)

arr[0] = 1     arr[1] = 2

이 상태에서 arr[0] =2 / arr[1]= 1이 되게 하고 싶다.

그러면 먼저 한 배열에 다른 배열의 값을 대입한다.

<h2>대입만 한 경우</h2>

1-1) arr[0] = arr[1] => 2

1-2) arr[1] = arr[0] => 2 (이미 위에서 변경을 시켰으므로 이런 식으로는 되지가 않는다)

-> 따라서 이런식으로 해줘야 한다. 

<h2>임시 변수 temp를 이용해 대입 한 경우</h2>

0-2) 변경되기 이전 (temp = arr[0] => 1 ) 

1-2) arr[0] = arr[1] => 2

2-2) arr[1]= temp => 1 

<hr> 


<h1> Q2 문자열 반대 순서로 출력 </h1> 

**반대로 저장이 되어야 반대로 출력됨**

따라서 정렬처럼 저장할 임시 변수가 필요한데, 여기서는 임시 변수를 char arr[] 로 정해서 문자열을 하나씩 잘라서 넣었고, 출력해서 해결.

char arr[4-i] = text1.charAt(i);  // 한쪽은 증가하고, 한쪽은 감소하는 식으로 반대여야 반대로 배열에 저장되서 출력이 됨. 

<hr>

<h1> Q3 최대값/ 최소값 출력</h1>

**기존 자료들을 비교해서, 그 중 가장 큰 (작은) 값을 출력. 비교하려면 일단 저장된 기준이 필요하고, 그 저장된 기준을 바탕으로 비교**

여기서는 저장된 기준이 아래와 같음 

int arr[] = {10, 20, 30, 40};

int max = arr[i];

int min = arr[i];

<hr>

<h1> Q4 수열 = 변수들의 합계 구하는 것</h1>

합계인 경우 j+= i;
